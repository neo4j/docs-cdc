= Example CDC usage in Go

[source, golang, role="nocollapse"]
----
package main

import (
	"context"
	"encoding/json"
	"fmt"
	"github.com/spf13/cobra"
	"github.com/tidwall/pretty"
	"log"
	"os"
	"os/signal"
	"sync"
	"sync/atomic"
	"time"

	"github.com/neo4j/neo4j-go-driver/v5/neo4j"
)

type CDCService struct {
	driver    neo4j.DriverWithContext
	database  string
	waitGroup sync.WaitGroup
	cursor    atomic.Pointer[string]
}

func (s *CDCService) from() string {
	return *s.cursor.Load()
}

func (s *CDCService) setFrom(from string) {
	s.cursor.Store(&from)
}

func (s *CDCService) earliestChangeID(ctx context.Context) (string, error) {
	session := s.driver.NewSession(ctx, neo4j.SessionConfig{DatabaseName: s.database})

	id, err := session.ExecuteRead(ctx, queryChangeID(ctx, "CALL cdc.earliest()"))
	if err != nil {
		return "", fmt.Errorf("unable to query earliest change id: %w", err)
	}

	return id.(string), nil
}

func (s *CDCService) currentChangeID(ctx context.Context) (string, error) {
	session := s.driver.NewSession(ctx, neo4j.SessionConfig{DatabaseName: s.database})

	id, err := session.ExecuteRead(ctx, queryChangeID(ctx, "CALL cdc.current()"))
	if err != nil {
		return "", fmt.Errorf("unable to query current change id: %w", err)
	}

	return id.(string), nil
}

func (s *CDCService) queryChanges(ctx context.Context) error {
	session := s.driver.NewSession(ctx, neo4j.SessionConfig{DatabaseName: s.database})

	_, err := session.ExecuteRead(ctx, func(tx neo4j.ManagedTransaction) (any, error) {
		result, err := tx.Run(ctx, "CALL cdc.query($from, $selectors)", map[string]any{
			"from":      s.from(),
			"selectors": []any{},
		})
		if err != nil {
			return "", err
		}

		var record *neo4j.Record
		for result.NextRecord(ctx, &record) {
			err := processRecord(record)
			if err != nil {
				return "", fmt.Errorf("error processing record: %w", err)
			}

			if idObj, exists := record.Get("id"); exists {
				id := idObj.(string)
				s.cursor.Store(&id)
			}
		}

		return *s.cursor.Load(), nil
	})
	if err != nil {
		return fmt.Errorf("unable to query current change id: %w", err)
	}

	return nil
}

func (s *CDCService) Start(ctx context.Context) error {
	if s.from() == "" {
		current, err := s.currentChangeID(ctx)
		if err != nil {
			return err
		}
		s.setFrom(current)
	}

	s.waitGroup.Add(1)
	go func(ctx context.Context) {
		defer func() {
			s.waitGroup.Done()
		}()

		timer := time.NewTimer(0 * time.Millisecond)
		for {
			select {
			case <-ctx.Done():
				return
			case <-timer.C:
				{
					err := s.queryChanges(ctx)
					if err != nil {
						log.Printf("error querying/processing changes: %v", err)
						return
					}

					timer.Reset(500 * time.Millisecond)
				}
			}
		}
	}(ctx)

	return nil
}

func (s *CDCService) WaitForExit() {
	s.waitGroup.Wait()
}

func queryChangeID(ctx context.Context, query string) func(tx neo4j.ManagedTransaction) (any, error) {
	return func(tx neo4j.ManagedTransaction) (any, error) {
		result, err := tx.Run(ctx, query, nil)
		if err != nil {
			return nil, err
		}

		record, err := result.Single(ctx)
		if err != nil {
			return nil, err
		}

		return record.Values[0].(string), nil
	}
}

func processRecord(record *neo4j.Record) error {
	jsonOutput, err := json.Marshal(asMap(record))
	if err != nil {
		return fmt.Errorf("unable to jsonify record: %w", err)
	}

	fmt.Println(string(pretty.Color(pretty.Pretty(jsonOutput), pretty.TerminalStyle)))

	return nil
}

func asMap(record *neo4j.Record) map[string]any {
	result := make(map[string]any, len(record.Keys))

	for i := 0; i < len(record.Keys); i++ {
		result[record.Keys[i]] = record.Values[i]
	}

	return result
}

func NewCDCService(uri string, username string, password string, database string, from string) (*CDCService, error) {
	driver, err := neo4j.NewDriverWithContext(uri, neo4j.BasicAuth(username, password, ""))
	if err != nil {
		return nil, fmt.Errorf("unable to create driver: %w", err)
	}

	cdc := &CDCService{
		driver:    driver,
		database:  database,
		waitGroup: sync.WaitGroup{},
		cursor:    atomic.Pointer[string]{},
	}
	cdc.setFrom(from)

	return cdc, nil
}

var (
	address  string
	database string
	username string
	password string
	from     string
)

func main() {
	rootCmd := &cobra.Command{
		Run: func(cmd *cobra.Command, args []string) {
			ctx, _ := signal.NotifyContext(context.Background(), os.Interrupt)

			cdc, err := NewCDCService(address, username, password, database, from)
			if err != nil {
				log.Fatal(err)
			}

			if err := cdc.Start(ctx); err != nil {
				log.Fatal(err)
			}

			fmt.Printf("starting...\n")
			cdc.WaitForExit()
			fmt.Printf("quitting...\n")
		},
	}

	rootCmd.Flags().StringVarP(&address, "address", "a", "bolt://localhost:7687", "Bolt URI")
	rootCmd.Flags().StringVarP(&database, "database", "d", "neo4j", "Database")
	rootCmd.Flags().StringVarP(&username, "username", "u", "neo4j", "Username")
	rootCmd.Flags().StringVarP(&password, "password", "p", "passw0rd", "Password")
	rootCmd.Flags().StringVarP(&from, "from", "f", "", "Change identifier to query changes from")

	cobra.CheckErr(rootCmd.Execute())
}
----